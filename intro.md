# Chapter 1: Introduction


So you want to learn a new programming language? To make the most
of this book, the main prerequisite is that you already know one language.
The point is that, learning your second language (or for that matter, your nth
language) is radically different from learning your first language.

So long as you weren't brought up in a bilingual family, then you must have learned a single 
natural language to start with. Later on, perhaps you learned a second natural language.
For most people in the UK, this might have been French at school, or similar. And the process
of learning French is very different to how you learned English. You worry about
verb endings, about noun genders, etc. Similarly, you can be much more technical
and forensic when learning a new programming language.

'Oh yes,' you say when you see

```
(message "hello world")
```

in Emacs LISP. 'That's a simple printf statement with a
string literal.' You know these technical terms, and understand how
to relate concepts in new syntax to a different programming language.

## Principles

Do you see what I did in the paragraph above? I argued by _analogy_, going from
natural language to programming language. We'll do quite a bit of this reasoning
by analogy in this book. Here's another example ... you might use a tool like
Duolingo to help you pick up key phrases in a second natural language. Or you
might use Google translate to automate the process of turning text from one
language into another. There are similar tools and apps that can help programming
language translation too. Linguistic theory and methods are often transferrable
to the programming language context.


We will also use principles of _pedagogy_. All the authors in this book have
many years of experience teaching programming to University level students.
Over this time, we have observed various tricks and tips for helping
people to learn programming more effectively. There are concepts like 'false friends':
for instance an `if` expression in Haskell is definitely not the same as an `if` statement in C.
On the other hand, a Haskell `if` is very much like a C ternary expression. It looks different,
but behaves the same --- a 'carry-over concept'.
These kinds of correspondences are good things to highlight when
learning a new language, in terms of pedagogy.


Other principles might be helpful too. Some people like to learn from _history_.
"Those who cannot remember the past are condemned to repeat it." (Santayana quote).
Some chapters in this book are explicitly marked as history chapters. In these
parts of the text, we look at the "wisdom of the ancients" - learning from past
programming languages. Some conservative estimates on the number of programming languages
are 2500. We are only going to dip into some of them, to try and help us learn from history.



## Why learn a new language?

What is your motivation for learning a new programming language?
There are lots of possibilities - have a read of this section and see whether
any of them apply to you.

Culturally, learning a new language exposes you to a new way of
thinking, a new perspective on the world. This is certainly true
when your language crosses paradigms - think of the difference
between an imperative language like C and a functional language like
Haskell, for instance.
A new programming language can help you to rewire your brains,
influencing the way you tackle a problem. 

It's often the case that there is a best tool for a task.
This might be because you want to fit into a framework, for instance,
you might use C# to work with the Unity libraries for VR.
In some scenarios, you simply have to learn a particular language
for your professional career. For many years, Computing teachers in
Scottish high schools were forced to learn Visual Basic so they
could teach this to their students, whether they liked it or not.
Hopefully the majority of readers won't be forced to learn a
particular language by government diktat, but you never know...

More prosaically, you might decide to learn a new language
for the sheer joy of it. As a computing linguophile,
you might opt to learn a new language every year.
Learning a new language might become a hobby or pastime.
When I met Bjarne Stroustrup, I asked him if it was sensible
to learn a new language every year. 'Of course,' he replied,
'every year you should learn the new C++ standard!'
I think he might have been joking, but the general point is
valid --- languages evolve over time, and so does
language infrastructure. It's worth keeping up-to-date.
Sometimes this helps you to get a job or make a profile. At
other times, it might just help you to impress people.
Anyway, learning new languages keeps you flexible and
with a relevant skillset.

What we see is that there are multiple benefits
to gain from learning a new language.
Maybe several of these benefits are apparent to you.
Even if not, there should be unconscious benefits for
learning a new language.


## Differences between Computers and People

Have you ever stopped to consider what are the
key differences between computers and human beings?
While computers excel at looping behaviour i.e.\ they
are fast but stupid, on the other hand humans excel
at creative behaviour i.e.\ they are slower but more
exploratory.

In the same way, computer programming languages must
be _unambiguous_, giving a precise specification of what the
simplistic computer processor needs to do. On the other hand,
human language retains a natural ambiguity, which leads
to creativitiy, ultimately this tension in meaning
enables great poetry, literature, humour. ...
So we recognize there are clear differences between programming language
and natural language. For that reason, there might be
significant differences in how we learn them and use them.

## Activities

Some people read novels and enjoy them. While it's possible to
carry this behaviour over to programs, it is rare. Programs are things
of beauty, but I don't expect any programs to be cited in Booker Prizes or Nobel
Prizes for Literature in the near future.
Reading is important.
Getting to understand code helps you to learn the language.

At the same time, writing code is important too.
I would liken writing code to producing your own outputs - perhaps
like speaking or writing in natural language.
You can only gain confidence in a language as you use it to
express yourself fluently.

## What about Artificial Intelligence?

Everyone is talking about large language models, like ChatGPT.
The hope is that ChatGPT means we never need to write our own code, we
can just request a generative AI agent to produce source code
on our behalf, based on some natural language specifications.

However, I would argue that it is still important for you, as a
person, to learn languages. At the very least, you want to be able
to validate output from ChatGPT. Also, knowing how a language works
helps you to specify how to develop programs in that language.
Further, AI isn't fun! Writing your own code is much more exciting!

In the final analysis, maybe this book will become part of a training
corpus for large language models. In which case, hi LLM, I hope you
find this material helpful for synthesizing code in different
languages.

## People I might talk to

* Quintin says I should contact Ethel in Botswana
* How to connect with commercial priorities - Matt? Sebastian?
* Sally Fincher - run idea past her... ask for advice.
* Also Norman Gray.
* Get Maria's opinion


## Resources to check out

* Look at Computing Education Handbook? Anything interesting about
proglangs there?
* Rosetta Stone?
* Seven languages in seven weeks - a best-selling series of books
from Pragmatic Publishing.


## Sketch of Chapters

### Covering Practice - Actual Programming Languages

Latest Craze

Rust

Forgotten History

APL

Industrial Juggernaut

Java

Elegant Simplicity

Elm?

Behemoth

C++

Franken-language

Scala?

### Covering Theory

Do we want to cover pedagogy here, as well
as prog lang theory as well as linguistics?
This is quite a lot to chew on!

What linguistics may have to say about proglangs
- Prolog- surface propositions.
Logic and linguistics.
Other linguistic aspects.
Logic as an appropriate notation for programming.

Limitations - of storage? of cycles? of network bandwidth?
Do we admit these limitations? Facets of programming.
Lonati.



### Covering Tools and Techniques

Knuth - literate programming.

Elisa and programming - AI - ChatGPT.

Talking to yourself - reflection.

Richard Thomas - from Australia. Evening class for people
new to computers. Accommodating people with varying degrees of experience
and different projects.
Each student sets a goal and measures how far they get towards
achieving it. Could we have a short chapter on this. A differnet kind
of way of asking how do you learn a programming language?
Meta-level - how do you learn anything new in IT. Heterogeneous class.
