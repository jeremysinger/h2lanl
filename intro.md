# Chapter 1: Introduction


So you want to learn a new programming language. To make the most
of this book, your key prerequisite is that you already know one language.
The point is that, learning your second language (or for that matter, your nth
language) is radically different from learning your first language.

So long as you weren't brought up in a bilingual family, then you learned one
natural language to start with. Later on, perhaps you learned a second natural language.
For most people in the UK, this is French at school, or similar. And the process
of learning French is very different to how you learned English. You worry about
verb endings, about noun genders, etc. Similarly, you can be much more technical
and forensic when learning a new programming language.

## Principles

Do you see what I did in the paragraph above? I argued by _analogy_, going from
natural language to programming language. We'll do quite a bit of this reasoning
by analogy in this book. Here's another example ... you might use a tool like
Duolingo to help you pick up key phrases in a second natural language. Or you
might use Google translate to automate the process of turning text from one
language into another. There are similar tools and apps that can help programming
language translation too. Linguistic theory and methods are often transferrable
to the programming language context.


We will also use principles of _pedagogy_. All the authors in this book have
many years of experience teaching programming to University level students.
Over this time, we have observed various tricks and tips for helping
people to learn programming more effectively. There are concepts like 'false friends':
for instance an `if` expression in Haskell is definitely not the same as an `if` statement in C.
On the other hand, a Haskell `if` is very much like a C ternary expression. It looks different,
but behaves the same --- a 'carry-over concept'.
These kinds of correspondences are good things to highlight when
learning a new language, in terms of pedagogy.


Other principles might be helpful too. Some people like to learn from _history_.
"Those who cannot remember the past are condemned to repeat it." (Santayana quote).
Some chapters in this book are explicitly marked as history chapters. In these
parts of the text, we look at the "wisdom of the ancients" - learning from past
programming languages. Some conservative estimates on the number of programming languages
are XXX. We are only going to dip into some of them, to try and help us learn from history.



## Why learn a new language?

What is your motivation for learning a new programming language?
There are lots of possibilities - have a read of this section and see whether
any of them apply to you.

Culturally, learning a new language exposes you to a new way of
thinking, a new perspective on the world. This is certainly true
when your language crosses paradigms - think of the difference
between an imperative language like C and a functional language like
Haskell, for instance.
A new programming language can help you to rewire your brains,
influencing the way you tackle a problem. 

It's often the case that there is a best tool for a task.
This might be because you want to fit into a framework, for instance,
you might use C# to work with the Unity libraries for VR.
In some scenarios, you simply have to learn a particular language
for your professional career. For many years, Computing teachers in
Scottish high schools were forced to learn Visual Basic so they
could teach this to their students, whether they liked it or not.
Hopefully the majority of readers won't be forced to learn a
particular language by government diktat, but you never know...

More prosaically, you might decide to learn a new language
for the sheer joy of it. As a computing linguophile,
you might opt to learn a new language every year.
Learning a new language might become a hobby or pastime.
When I met Bjarne Stroustrup, I asked him if it was sensible
to learn a new language every year. 'Of course,' he replied,
'every year you should learn the new C++ standard!'
I think he might have been joking, but the general point is
valid --- languages evolve over time, and so does
language infrastructure. It's worth keeping up-to-date.
Sometimes this helps you to get a job or make a profile. At
other times, it might just help you to impress people.
Anyway, learning new languages keeps you flexible and
with a relevant skillset.

Consider what are the differences between computers and humans.
Looping behaviour - computers and people.
Cmoputers - fast but stupid.
People - slow, less repeatable, but clever.

Reading code as opposed to writing code.
pegadogy again.


Multiple benefits ... 
Freud's deep idea - for small things in life, do an action to achieve one goal. But for the important things in life, spouse, house, job - overdetermined - multiple pluses - slightly counterintuitive.
Systematic thinking - lots of criteria to satisfy.


## People I might talk to

* Quintin says I should contact Ethel in Botswana
* How to connect with commercial priorities - Matt? Sebastian?
* Sally Fincher - run idea past her... ask for advice.
* Also Norman Gray.
* Get Maria's opinion


## Resources to check out

* Look at Computing Education Handbook? Anything interesting about
proglangs there?
* Rosetta Stone?
* Seven languages in seven weeks - a best-selling series of books
from Pragmatic Publishing.


## Sketch of Chapters

### Covering Practice - Actual Programming Languages

Latest Craze

Rust

Forgotten History

APL

Industrial Juggernaut

Java

Elegant Simplicity

Elm?

Behemoth

C++

Franken-language

Scala?

### Covering Theory

Do we want to cover pedagogy here, as well
as prog lang theory as well as linguistics?
This is quite a lot to chew on!

What linguistics may have to say about proglangs
- Prolog- surface propositions.
Logic and linguistics.
Other linguistic aspects.
Logic as an appropriate notation for programming.

Limitations - of storage? of cycles? of network bandwidth?
Do we admit these limitations? Facets of programming.
Lonati.



### Covering Tools and Techniques

Knuth - literate programming.

Elisa and programming - AI - ChatGPT.

Talking to yourself - reflection.

Richard Thomas - from Australia. Evening class for people
new to computers. Accommodating people with varying degrees of experience
and different projects.
Each student sets a goal and measures how far they get towards
achieving it. Could we have a short chapter on this. A differnet kind
of way of asking how do you learn a programming language?
Meta-level - how do you learn anything new in IT. Heterogeneous class.
